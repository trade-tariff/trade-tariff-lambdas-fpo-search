#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail
set -o noclobber

source .circleci/bin/needsmodel

fetch_account_id ()
{
  aws sts get-caller-identity --query Account --output text
}

fetch_latest_ami_image_id_by_name ()
{
  image_name_query=$1
  region=${2:-'us-east-1'}
  owner=$(fetch_account_id)

  aws ec2 describe-images \
    --region "$region" \
    --owners "$owner" \
    --filters "Name=name,Values=${image_name_query}" 'Name=state,Values=available' \
    --query 'reverse(sort_by(Images, &CreationDate))[:1].ImageId' \
    --output text
}

INSTANCE_ID=''

launch_ec2_instance ()
{
  name="fpo-search-training-$SHA"
  retries=2
  delay=5
  region=$1
  az=$2
  subnet_id=$3
  security_group_ids=$4
  key_pair_name=$5
  instance_type=$6
  source_ami_region="us-east-1"
  .circleci/bin/copyami "$LATEST_AMI" "$source_ami_region" "$region"
  ami_id=$(fetch_latest_ami_image_id_by_name "FPO Training*" "$region")

  echo "Launching EC2 instance in $region with configuration..."
  echo
  echo "üåç Region: $region"
  echo "üìÄ AMI: $ami_id"
  echo "ü§ñ Instance Type: $instance_type"
  echo "‚òéÔ∏èüìûSubnet ID: $subnet_id"
  echo "üîì Security Group IDs: $security_group_ids"
  echo "üîì Key Pair Name: $key_pair_name"
  echo "üöÄ Instance Name: $name"
  echo

  for ((i=0; i<retries; i++)); do
    set +o errexit
    INSTANCE_ID=$(aws ec2 run-instances \
      --image-id "$ami_id" \
      --subnet-id "$subnet_id" \
      --security-group-ids "$security_group_ids" \
      --instance-type $instance_type \
      --key-name "$key_pair_name" \
      --block-device-mappings '[{"DeviceName":"/dev/xvda","Ebs":{"VolumeSize":512,"DeleteOnTermination":true}}]' \
      --associate-public-ip-address \
      --region "$region" \
      --output text \
      --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$name}]" \
      --query 'Instances[0].InstanceId' 2>&1)
    set -o errexit

    if [[ "$INSTANCE_ID" != *"InsufficientInstanceCapacity"* ]]; then
      echo "$INSTANCE_ID"  # Return the instance ID if successful
      return 0
    fi

    echo "Insufficient capacity. Retrying in $delay seconds..."
    sleep "$delay"
    delay=$((delay * 2))
  done

  echo "Failed to launch instance after $retries retries in $region"
}

DESTINATION_REGION=''

try_launch_ec2_instance ()
{
  candidate_regions=$(.circleci/bin/getmodelregions \
    --instance-type "$INSTANCE_TYPE" \
    --create-security-group \
    --create-key-pair)

  echo
  echo -e "Candidate regions:\n\n$candidate_regions\n"

  if [[ "$candidate_regions" == '' ]]; then
    echo "No regions available to launch instance of this instance type $INSTANCE_TYPE."
    exit 1
  fi

  for region in $candidate_regions; do
    INSTANCE_ID=''
    IFS='|' read -r region az subnet_id security_group_ids key_pair_name instance_type <<< "$region"

    launch_ec2_instance "$region" "$az" "$subnet_id" "$security_group_ids" "$key_pair_name" "$instance_type"

    if [[ "$INSTANCE_ID" != '' ]] || [[ "$INSTANCE_ID" != *"InsufficientInstanceCapacity"* ]]; then
      DESTINATION_REGION="$region"
      break
    fi
  done

  if [[ "$INSTANCE_ID" == '' ]] || [[ "$INSTANCE_ID" == *"InsufficientInstanceCapacity"* ]]; then
    echo "Failed to launch instance in any region."
    exit 1
  fi
}

wait_for_instance_to_be_available ()
{
  aws ec2 wait instance-status-ok --instance-ids "$1" --region "$DESTINATION_REGION"
}

fetch_ec2_instance_public_ip ()
{
  aws ec2 describe-instances --region "$DESTINATION_REGION" --instance-ids "$1" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text
}

store_ec2_private_key ()
{
  secret_id=$1
  region='eu-west-2'

  rm -f ~/.ssh/"$KEY_PAIR_NAME".pem

  aws secretsmanager get-secret-value \
    --secret-id "$secret_id" \
    --region "$region" \
    --query 'SecretString' \
    --output text > ~/.ssh/"$KEY_PAIR_NAME".pem

  chmod 600 ~/.ssh/"$KEY_PAIR_NAME".pem
}

execute_command ()
{
  ssh -i ~/.ssh/"$KEY_PAIR_NAME".pem -o StrictHostKeyChecking=no ec2-user@"$1" "$2"
}

validate_connection ()
{
  execute_command "$1" "echo 'Connection successful!'"
}

bring_code_inline ()
{
  branch_name=$(git rev-parse --abbrev-ref HEAD)

  execute_command "$1" "cd $PROJECT && git fetch origin $branch_name:$branch_name && git checkout $branch_name"
}

load_latest_input_data ()
{
  aws s3 cp s3://"$MODEL_BUCKET_NAME/raw_source_data.zip" .
  scp -i ~/.ssh/"$KEY_PAIR_NAME".pem -o StrictHostKeyChecking=no raw_source_data.zip ec2-user@"$1":~/"$PROJECT"
  execute_command "$1" "cd $PROJECT && unzip raw_source_data.zip"
}

run_training_script_on_ec2_instance ()
{
  execute_command "$1" "cd $PROJECT && make train"
}

run_benchmarks_on_ec2_instance ()
{
  s3_prefix="$VERSION-$SHA"

  # Prepare benchmarking data
  aws s3 cp s3://"$MODEL_BUCKET_NAME/benchmarking_data.zip" .
  scp -i ~/.ssh/"$KEY_PAIR_NAME".pem -o StrictHostKeyChecking=no benchmarking_data.zip ec2-user@"$1":~/"$PROJECT"
  execute_command "$1" "cd $PROJECT && unzip benchmarking_data.zip"

  # Run benchmarks
  execute_command "$1" "cd $PROJECT && make benchmark"
  execute_command "$1" "cd $PROJECT && mv running_losses.json benchmarking_data/results/running_losses.json"

  # Copy benchmarking results
  execute_command "$1" "cd $PROJECT && zip -r benchmark_results.zip benchmarking_data"
  scp -i ~/.ssh/"$KEY_PAIR_NAME".pem -o StrictHostKeyChecking=no ec2-user@"$1":~/"$PROJECT"/benchmark_results.zip .
  aws s3 cp benchmark_results.zip s3://"$MODEL_BUCKET_NAME"/"$s3_prefix"/benchmark_results.zip
}

copy_model_from_ec2_instance ()
{
  s3_prefix="$VERSION-$SHA"

  execute_command "$1" "cd $PROJECT && zip model.zip target/model.pt target/subheadings.pkl"
  scp -i ~/.ssh/"$KEY_PAIR_NAME".pem -o StrictHostKeyChecking=no ec2-user@"$1":~/"$PROJECT"/model.zip .
  scp -i ~/.ssh/"$KEY_PAIR_NAME".pem -o StrictHostKeyChecking=no ec2-user@"$1":~/"$PROJECT"/search-config.toml .
  aws s3 cp model.zip s3://"$MODEL_BUCKET_NAME/$s3_prefix/model.zip"
  aws s3 cp search-config.toml s3://"$MODEL_BUCKET_NAME/$s3_prefix/search-config.toml"
}

terminate_ec2_instance ()
{
  aws ec2 terminate-instances --instance-ids "$1" --region $DESTINATION_REGION
}

on_exit ()
{
  local old_status=$?

  if [[ "$INSTANCE_ID" != '' ]]; then
    echo "Terminating EC2 instance..."
    terminate_ec2_instance "$INSTANCE_ID"
  fi

  exit $old_status
}

trap on_exit EXIT # Ensure that the EC2 instance is terminated after any failure

if needsmodel; then
  echo "Model needs to be trained"
else
  echo "Model does not need to be trained"
  exit 0
fi

INSTANCE_TYPE=p3.8xlarge
LATEST_AMI=$(fetch_latest_ami_image_id_by_name "FPO Training*")
KEY_PAIR_NAME=fpo-training
MODEL_BUCKET_NAME=trade-tariff-models-382373577178
ACCOUNT_ID=$(fetch_account_id)
PROJECT=trade-tariff-lambdas-fpo-search
SHA=$(git rev-parse --short HEAD)
VERSION=$(cat search-config.toml | grep version | awk '{print $3}' | sed 's/"//g')
BRANCH=$(git rev-parse --abbrev-ref HEAD)

try_launch_ec2_instance

PUBLIC_IP=$(fetch_ec2_instance_public_ip "$INSTANCE_ID")

echo "Launching EC2 instance with configuration..."
echo
echo "üìÄ AMI: $LATEST_AMI"
echo "ü§ñ Instance Type: $INSTANCE_TYPE"
echo "‚òéÔ∏èüìûPublic IP: $PUBLIC_IP"
echo "üîì Key Pair Name: $KEY_PAIR_NAME"
echo "üíø Model Bucket Name: $MODEL_BUCKET_NAME"
echo "üíª Account ID: $ACCOUNT_ID"
echo "üì¶ Project: $PROJECT"
echo "üåê SHA: $SHA"
echo "üîñ Version: $VERSION"
echo "üå≥ Branch: $BRANCH"
echo "üöÄ Instance ID: $INSTANCE_ID"
echo

echo "Waiting for instance to be available..."
wait_for_instance_to_be_available "$INSTANCE_ID"
echo "Instance is now available!"

echo "Retrieving private key..."
store_ec2_private_key "fpo-search-training-pem"

echo "Validating connection..."
validate_connection "$PUBLIC_IP"

echo "Bringing code inline..."
bring_code_inline "$PUBLIC_IP"

echo "Loading latest input data..."
load_latest_input_data "$PUBLIC_IP"

echo "Running training script on EC2 instance..."
run_training_script_on_ec2_instance "$PUBLIC_IP"

echo "Copying model from EC2 instance..."
copy_model_from_ec2_instance "$PUBLIC_IP"

echo "Running benchmarks..."
run_benchmarks_on_ec2_instance "$PUBLIC_IP"

echo "Terminating EC2 instance..."
terminate_ec2_instance "$INSTANCE_ID"
